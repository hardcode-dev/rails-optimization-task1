# Case-study оптимизации

## Актуальная проблема
В нашем проекте возникла серьёзная проблема.

Необходимо было обработать файл с данными, чуть больше ста мегабайт.

У нас уже была программа на `ruby`, которая умела делать нужную обработку.

Она успешно работала на файлах размером пару мегабайт, но для большого файла она работала слишком долго, и не было понятно, закончит ли она вообще работу за какое-то разумное время.

Я решил исправить эту проблему, оптимизировав эту программу.

## Формирование метрики
Для того, чтобы понимать, дают ли мои изменения положительный эффект на быстродействие программы я придумал использовать такую метрику: *тут ваша метрика*

## Гарантия корректности работы оптимизированной программы
Программа поставлялась с тестом. Выполнение этого теста в фидбек-лупе позволяет не допустить изменения логики программы при оптимизации.

## Feedback-Loop
Для того, чтобы иметь возможность быстро проверять гипотезы я выстроил эффективный `feedback-loop`, который позволил мне получать обратную связь по эффективности сделанных изменений за *время, которое у вас получилось*

Вот как я построил `feedback_loop`: *как вы построили feedback_loop*

## Вникаем в детали системы, чтобы найти главные точки роста
Для того, чтобы найти "точки роста" для оптимизации я воспользовался *инструментами, которыми вы воспользовались*

Вот какие проблемы удалось найти и решить

### Ваша находка №1

убираем лишний <Class::Date>#parse

Finish in 2.33
 %self      total      self      wait     child     calls  name                           location
 26.43      0.523     0.242     0.000     0.281    37500   <Class::Date>#parse
 19.93      0.768     0.182     0.000     0.585     1652   Array#map
 13.17      0.121     0.121     0.000     0.000    75000   Regexp#match

Finish in 0.37
 %self      total      self      wait     child     calls  name                           location
 47.98      0.152     0.121     0.000     0.032     1352   Array#map
 19.62      0.049     0.049     0.000     0.000      150   Array#select
 8.05      0.020     0.020     0.000     0.000    75000   String#to_i

### Ваша находка №2
Finish in 1.82
8.19      0.289     0.289     0.000     0.000  1200000   String#to_i

Finish in 1.62
0.13      0.003     0.003     0.000     0.000     3000   String#to_i

### Ваша находка 3
Finish in 1.62
  8.73      0.220     0.220     0.000     0.000   765200   String#upcase

Finish in 1.32
0.05      0.001     0.001     0.000     0.000     3000   String#upcase

### Ваша находка 4
Finish in 1.31
 %self      total      self      wait     child     calls  name                           location
 48.08      0.965     0.965     0.000     0.000     3601   Array#map

переписываем алгоритм, избавляемся от всех .map
Finish in 0.02

### Ваша находка 5
увеличиваем файл
 30.43      0.048     0.048     0.000     0.000    28801   String#split

рефакторинг
 21.08      0.029     0.029     0.000     0.000    14401   String#split

### Ваша находка 6
увеличиваем файл
Finish in 0.31
 14.89      0.029     0.020     0.000     0.009    12000   Object#parse_session

рефакторинг, избавляемся от метода parse_session
Finish in 0.21

### Ваша находка 7
увеличиваем файл
Finish in 0.84
  2.68      0.055     0.055     0.000     0.000    38400   Object#parse_user              /Users/dmitriybadichan/Desktop/rails-optimization-task1/work_method.rb:16

рефакторинг, избавляемся от метода parse_user
Finish in 0.81

### Ваша находка 8
Finish in 0.81

рефакторинг, строковые ключи в символьные
Finish in 0.63

## Результаты
В результате проделанной оптимизации наконец удалось обработать файл с данными.
Удалось улучшить метрику системы до 23.49 и уложиться в заданный бюджет.
```
$ ruby ./large-task-1.rb

time = Benchmark.realtime do
  work('data_large.txt', disable_gc: false)
end

puts "Finish in #{time.round(2)}"

Finish in 23.49
```

*Какими ещё результами можете поделиться*

## Защита от регрессии производительности
Для защиты от потери достигнутого прогресса при дальнейших изменениях программы *о performance-тестах, которые вы написали*
