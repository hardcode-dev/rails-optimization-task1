# Case-study оптимизации

## Актуальная проблема
В нашем проекте возникла серьёзная проблема.

Необходимо было обработать файл с данными, чуть больше ста мегабайт.

У нас уже была программа на `ruby`, которая умела делать нужную обработку.

Она успешно работала на файлах размером пару мегабайт, но для большого файла она работала слишком долго, и не было понятно, закончит ли она вообще работу за какое-то разумное время.

Я решил исправить эту проблему, оптимизировав эту программу.

## Формирование метрики
Для того, чтобы понимать, дают ли мои изменения положительный эффект на быстродействие программы я придумал использовать такую метрику: бенчмарком замерять сколько необходимо времени для успешного завершения программы

## Гарантия корректности работы оптимизированной программы
Программа поставлялась с тестом. Выполнение этого теста в фидбек-лупе позволяет не допустить изменения логики программы при оптимизации.

## Feedback-Loop
Для того, чтобы иметь возможность быстро проверять гипотезы я выстроил эффективный `feedback-loop`, который позволил мне получать обратную связь по эффективности сделанных изменений за 15 сек

Вот как я построил `feedback_loop`:
1. Замерил с помощью бенчмарка сколько времени нужно программе для завершения работы
2. Увеличил размер входного файла, чтобы работа программы занимала примерно 10+ сек
3. Снял метрики выполнения работы программы с помощью stack-prof и ruby-prof
4. Проанализировал метрики
5. Нашел главную точку роста
6. Оптимизировал точку роста
7. Получилось увеличить скорость? -> Commit. Не получилось увеличить или получили обратный эффект -> Revert и go to пункт 6


## Вникаем в детали системы, чтобы найти главные точки роста
Для того, чтобы найти "точки роста" для оптимизации я воспользовался инструментами stack-prof и ruby-prof.

Вот какие проблемы удалось найти и решить

### Ваша находка №1
- Какой отчёт показал главную точку роста
- Профайлеры показали, что больше всего времени уходит код `user_sessions = sessions.select { |session| session['user_id'] == user['id'] }`, т.к используется не оптимальная структура данных для поиска по уникальным значениям
- Как вы решили её оптимизировать
- Использовать более подходящую структуру данных для этой цели
- Как изменилась метрика
- Скорость увеличилась в 66 раз
- Как изменился отчёт профилировщика - исправленная проблема перестала быть главной точкой роста?
- Да, проблема перестала быть главной точной роста

### Ваша находка №2
- Какой отчёт показал главную точку роста
- Профайлер `RubyProf` показал, что не оптимально работает метод для построения отчёта об уникальный браузерах. Так-же заметил что можно оптимизировать отчёты usedIE, alwaysUsedChrome 
- Как вы решили её оптимизировать
- Сделал посчёт уникальных браузеров через хэш, изменил немного отчёты usedIE, alwaysUsedChrome
- Как изменилась метрика
- Бенчмарк показал увеличение скорости примерно на 10-15%
- как изменился отчёт профилировщика - исправленная проблема перестала быть главной точкой роста?
- Да, проблема перестала быть главной точной роста

### Ваша находка №3
- Какой отчёт показал главную точку роста
- StackProf показал, что программа 40% времени занимается конкатенацией массива, когда начал копать - понял что массив 
это не оптимальная структура для текущей задачи
- Как вы решили её оптимизировать
- Заменил массив на хэш, объеденил сбор статистики по пользователю в одно итерацию
- Как изменилась метрика
- Бенчмарк показал прирост скорости примерно в три раза
- Как изменился отчёт профилировщика - исправленная проблема перестала быть главной точкой роста?
- Да, проблема перестала быть точкой роста, новая точка роста - парсинг даты

### Ваша находка №4
- Какой отчёт показал главную точку роста
- StackProf показал, новую точку роста - парсинг даты
- Как вы решили её оптимизировать
- Использовал более оптимальный метод для парсинга данных
- Как изменилась метрика
- Бенчмарк показал прирост скорости примерно на 10%
- Как изменился отчёт профилировщика - исправленная проблема перестала быть главной точкой роста?
- Да, проблема перестала быть точкой роста, новая точка роста - сплитинг строки

### Ваша находка №5
- Какой отчёт показал главную точку роста
- StackProf показал, новую точку роста - сплит строки
- Как вы решили её оптимизировать
- Поптался прочитать файл по строчкам, вместо загрузки и разбиение его на строки методом сплит
- Как изменилась метрика
- Бенчмарк показал прирост скорости примерно на 5%
- Как изменился отчёт профилировщика - исправленная проблема перестала быть главной точкой роста?
- Нет, но стала меньше выраженной, буду копать дальше

### Ваша находка №6
- Какой отчёт показал главную точку роста
- Не получилось оптимизировать главную точку роста, если String#split со вторым аргументом только ухудшил производительность. Начал копать дальше и обнаружил ошибку в алгоритме - мы много раз вызываем upcase на браузерах
- Как вы решили её оптимизировать
- Оптимизировал код, чтобы делать это только один раз
- Как изменилась метрика
- Бенчмарк показал прирост скорости примерно на 10-15%
- Как изменился отчёт профилировщика - исправленная проблема перестала быть главной точкой роста?
- Стало сложнее обнаружить точку роста, т.к в разных инструментах она разная, при поиске неоптимизированного кода теперь нужно учитывать результаты некольких инструментов. Сейчас новая точка роста вроде как Object#parse_session

### Ваша находка №7
- Какой отчёт показал главную точку роста
- Не получилось оптимизировать главную точку роста, если String#split со вторым аргументом только ухудшил производительность. Начал копать дальше и обнаружил ошибку в алгоритме - мы много раз вызываем upcase на браузерах
- Как вы решили её оптимизировать
- Оптимизировал код, чтобы делать это только один раз
- Как изменилась метрика
- Бенчмарк показал прирост скорости примерно на 10-15%
- Как изменился отчёт профилировщика - исправленная проблема перестала быть главной точкой роста?
- Стало сложнее обнаружить точку роста, т.к в разных инструментах она разная, при поиске неоптимизированного кода теперь нужно учитывать результаты некольких инструментов. Сейчас новая точка роста вроде как Object#parse_session

### Ваша находка №8
- Какой отчёт показал главную точку роста
- Не получилось оптимизировать главную точку роста, Object#parse_session
- Как вы решили её оптимизировать
- Убрал неиспользуемые переменные из #parse_session и #parse_user
- Как изменилась метрика
- Бенчмарк показал прирост скорости примерно на 10%, но в процентном соотношении всё осталось как было, подозреваю что на компьютере какие-то процессы завершились и я получил такой прирост
- Как изменился отчёт профилировщика - исправленная проблема перестала быть главной точкой роста?
- Нет

### Ваша находка №9
- Какой отчёт показал главную точку роста
- Не получилось оптимизировать главную точку роста, Object#parse_session
- Как вы решили её оптимизировать
- Убрал неиспользуемые переменные из #parse_session и #parse_user
- Как изменилась метрика
- Бенчмарк показал прирост скорости примерно на 10%, но в процентном соотношении всё осталось как было, подозреваю что на компьютере какие-то процессы завершились и я получил такой прирост
- Как изменился отчёт профилировщика - исправленная проблема перестала быть главной точкой роста?
- Нет

### Ваша находка №9
- Какой отчёт показал главную точку роста
- RubyProf graph продолжает показывать главную точку роста Object#parse_session
- Как вы решили её оптимизировать
- Забил на неё и попытался оптимизировать "в слепую" - убрал класс user и его маппинг
- Как изменилась метрика
- Получил прирост 2-3%, в районе погрешности... Больше идей для оптимизации при помощи инструментов нету.
- Как изменился отчёт профилировщика - исправленная проблема перестала быть главной точкой роста?
- Нет

### Ваша находка №10
- Какой отчёт показал главную точку роста
- Всё так-же Object#parse_session
- Как вы решили её оптимизировать
- Убрал лишний мапинг в сборе статистики, значительного прироста это не дало
- Как изменилась метрика
- Никак, всё в районе погрешности
- Как изменился отчёт профилировщика - исправленная проблема перестала быть главной точкой роста?
- Нет

### Ваша находка №11
- Какой отчёт показал главную точку роста
- Всё так-же Object#parse_session
- Как вы решили её оптимизировать
- Заменил обращении к хэшу в критических местах - заменил строки на символы
- Как изменилась метрика
- Бенчмарк показал прирост производительности примерно 10-15%
- Как изменился отчёт профилировщика - исправленная проблема перестала быть главной точкой роста?
- Нет, в процентном соотношении всё осталось так-же

## Результаты
В результате проделанной оптимизации наконец удалось обработать файл с данными.
Удалось улучшить метрику системы с невозможности обработать файл до выполнения программы за 20 секунд с выключеным GC и 26-27 секунд с включенным. Тем самым удалось уложиться в заданный бюджет.

На удивление - оптимизация тех мест, которые я бы пошел оптимизировать "в слепую", в первую очерень - дала намного меньший результат чем я ожидал. В целом - очень понравился процесс оптимизации по данному фреймворку.

## Защита от регрессии производительности
Для защиты от потери достигнутого прогресса при дальнейших изменениях программы *о performance-тестах, которые вы написали*

