# Case-study оптимизации

## Актуальная проблема
В нашем проекте возникла серьёзная проблема.

Необходимо было обработать файл с данными, чуть больше ста мегабайт.

У нас уже была программа на `ruby`, которая умела делать нужную обработку.

Она успешно работала на файлах размером пару мегабайт, но для большого файла она работала слишком долго, и не было понятно, закончит ли она вообще работу за какое-то разумное время.

Я решил исправить эту проблему, оптимизировав эту программу.

## Формирование метрики
Для того, чтобы понимать, дают ли мои изменения положительный эффект на быстродействие программы я придумал использовать такую метрику: за какое время программа выполняется для файла размером 10000 строк. Начальное значение: 2.07 секунд. Кроме того, провел анализ асимптотики программы и выяснил, что зависимостью времени от объема данных является O(N^2)

## Гарантия корректности работы оптимизированной программы
Программа поставлялась с тестом. Выполнение этого теста в фидбек-лупе позволяет не допустить изменения логики программы при оптимизации.

## Feedback-Loop
Для того, чтобы иметь возможность быстро проверять гипотезы я выстроил эффективный `feedback-loop`, который позволил мне получать обратную связь по эффективности сделанных изменений за несколько секунд.
Для этого я предварительно сделал тест производительности, а затем выстроил такой feedback_loop: 
1. С помощью профилировщика нахожу место, которое необходимо оптимизировать
2. Оптимизирую его
3. Запускаю тесты, чтобы убедиться, что ничего не поломалось
4. Запускаю тесты производительности, чтобы убедиться, что программа стала быстрее работать

## Вникаем в детали системы, чтобы найти главные точки роста
Для того, чтобы найти "точки роста" для оптимизации я воспользовался следующими инструментами:
1. ruby-prof в режиме Flat;
2. ruby-prof в режиме Graph;
3. ruby-prof в режиме Callgrind;
4. stackprof.

Вот какие проблемы удалось найти и решить

### Медленная работа метода select для массива сессий
- какой отчёт показал главную точку роста: ruby-prof в режиме Flat;
- как вы решили её оптимизировать: сгруппировал хэши сессий по значению user_id, чтобы необходимый подмассив находился быстрее
- как изменилась метрика: Время выполнения работы программы для файла размером в 10000 строк выросло в 4 раза
- как изменился отчёт профилировщика - исправленная проблема перестала быть главной точкой роста?: да

### Медленная работа метода all? массива браузеров для сбора уникальных браузеров
- какой отчёт показал главную точку роста: ruby-prof в режиме Graph;
- как вы решили её оптимизировать: заменил метод all? на include?
- как изменилась метрика: Время выполнения работы программы для файла размером в 10000 строк выросло в 1.5 раз
- как изменился отчёт профилировщика - исправленная проблема перестала быть главной точкой роста?: да

### Медленная работа метода find? массива сессий для сбора пользовательских сессий
- какой отчёт показал главную точку роста: ruby-prof в режиме Callgrind;
- как вы решили её оптимизировать: заменил find на bsearch
- как изменилась метрика: скорость работы увеличилась примерно в 3 раза (0.1 секунды для файла в 10000 строк)
- как изменился отчёт профилировщика - исправленная проблема перестала быть главной точкой роста?: да

### Медленная работа метода + массивов
- какой отчёт показал главную точку роста: ruby-prof в режиме graph;
- как вы решили её оптимизировать: заменил "+" на push
- как изменилась метрика: скорость работы для больших файлов сильно увеличилась, асимптотика стала более линейной 
- как изменился отчёт профилировщика - исправленная проблема перестала быть главной точкой роста?: да

### Медленная работа метода collect_stats_from_users
- какой отчёт показал главную точку роста: ruby-prof в режиме graph;
- как вы решили её оптимизировать: Оптимизировал конкатенацию строк в методе, объединил вызываемые блоки в 1 блок, выделил и переиспользовал общие переменные в блоках, оптимизировал операцию присваивания значения ключу в методе
- как изменилась метрика: скорость работы для файла в 10000 строк выросла до 0.06 секунд
- как изменился отчёт профилировщика - исправленная проблема перестала быть главной точкой роста?: да

## Результаты
В результате проделанной оптимизации наконец удалось обработать файл с данными.
Удалось улучшить метрику системы с *2.07 секунд до 0.06 секунд*.

*К сожалению, уложиться в заданный бюджет не получилось из-за непонимания процесса дальнейшей оптимизации главной точки роста, которой является метод split, вызываемый при парсинге каждой отдельной строки. Удалось добиться метрики в 70 секунд для файла с данными.*

## Защита от регрессии производительности
Для защиты от потери достигнутого прогресса при дальнейших изменениях программы я написал performance-тест, который во время процесса разработки тестировал скорость работы для файла размером в 10000 строк.

