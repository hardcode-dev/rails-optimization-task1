# Case-study оптимизации

## Актуальная проблема
В нашем проекте возникла серьёзная проблема.

Необходимо было обработать файл с данными, чуть больше ста мегабайт.

У нас уже была программа на `ruby`, которая умела делать нужную обработку.

Она успешно работала на файлах размером пару мегабайт, но для большого файла она работала слишком долго, и не было понятно, закончит ли она вообще работу за какое-то разумное время.

Я решил исправить эту проблему, оптимизировав эту программу.

## Формирование метрики
Для того, чтобы понимать, дают ли мои изменения положительный эффект на быстродействие программы я решил использовать такую метрику: *время обработки файла с 8000 тыс. строк информации*

## Гарантия корректности работы оптимизированной программы
Программа поставлялась с тестом. Выполнение этого теста в фидбек-лупе позволяет не допустить изменения логики программы при оптимизации.

## Feedback-Loop
Для того, чтобы иметь возможность быстро проверять гипотезы я выстроил эффективный `feedback-loop`, который позволил мне получать обратную связь по эффективности сделанных изменений за *20 - 60 секунд*

Вот как я построил `feedback_loop`:
- выбор точки роста на основании данных профайлеров
- рефакторинг кода
- бенчмарк
- защита метрики
## Вникаем в детали системы, чтобы найти главные точки роста
Для того, чтобы найти "точки роста" для оптимизации я воспользовался:
- `benchmark/ips` статистический тест bootstrap с отключением GC и прогревом кэшей
- `benchmark` тест на время выполнения программы
- `ruby-prof` в форматах flat, graph и callstack
- `rbspy` flamegraph
- `rspec-benchmark`

Вот какие проблемы удалось найти и решить

### Ваша находка №1
- RubyProf::GraphHtml показал главную точку роста: поиск сессий `Array#select`
- Убрал поиск сессий (sessions.select) для каждого юзера из итератора each, заменив его на sessions.group_by по user_id
- метрика уменишилась в 6.07 раз
- исправленная проблема перестала быть главной точкой роста

### Ваша находка №2
- RubyProf::GraphHtmlPrinter показал главную точку роста `Array#each`, `Array#all?`
- Убрал подсчет количества уникальных браузеров в отдельном итераторе. Массив браузеров (uniqueBrowsers) теперь формируется при итерации по file_lines, затем фильтруется один раз с помощью browsers.uniq
- 6.07 -> 6.14
- исправленная проблема перестала быть главной точкой роста

### Ваша находка №3
- RubyProf::GraphHtmlPrinter, RubyProf::CallStackPrinter показали главную точку роста `Array#map` и `String#to_i`
- Оптимизировал количество вызовов `Array#map` и `String#to_i` для подсчета статистики времени сессии
- 6.14 -> 7.46
- исправленная проблема перестала быть главной точкой роста

### Ваша находка №4
- RubyProf::GraphHtmlPrinter, RubyProf::CallStackPrinter показали главную точку роста - итерацию по строкам файла и вызовы методов parse_user,parse_session
- Оптимизировал парсинг файла с помощью `File#readlines`, убрал конкатенацию для массивов в методе `work` и методы parse_user и parse_session.
- 7.46 -> 14.31
- исправленная проблема перестала быть главной точкой роста

### Ваша находка №5
- RubyProf::GraphHtmlPrinter, RubyProf::CallStackPrinter показали главную точку роста - парсинг дат `Date#parse`
- Рефакторинг сбора дат сессий с использованием `Date#strptime`
- 14.31 -> 16.31
- исправленная проблема перестала быть главной точкой роста

### Ваша находка №6
- RubyProf::CallStackPrinter показал главную точку роста - конкатенация строк для формирования ключа юзера в репорте
- Рефакторинг метода collect_stats_from_users, убрал конкатенацию и перенес логику формирования json ключа в класс User
- 16.31 -> 24.54
- исправленная проблема перестала быть главной точкой роста

### Ваша находка №7
- RubyProf::CallStackPrinter показал главную точку роста - конкатенация строк и `String#upcase` при подготовке данных репорта
- Перенос метода `String#upcase` в метод parse_session. Замена конкатенации строк на интерполяцию
- 24.54 -> 26.46
- исправленная проблема перестала быть главной точкой роста

### Ваша находка №8
- rbspy flamegraph показал главную точку роста - блочный вызов метода `Hash#merge` в методе `#collect_stats_from_users`
- Рефакторинг метода `#collect_stats_from_users`, добавление отдельного метода `#render_user_stats` для генерации статистики сессий пользователя. Добавление класса статистики `UserSessionStats` и мемоизация статистики для пользователя `User#stats`.
- 26.46 -> 28.36
- исправленная проблема перестала быть главной точкой роста

## Результаты
В результате проделанной оптимизации наконец удалось обработать файл с данными.
Удалось улучшить метрику системы с *~0.7 секунды, до ~0.028* и уложиться в заданный бюджет.

*Время выполнения уменьшилась в ~28.4 раза, количество итераций в секунду увеличилось в ~30 раз, при этом стала возможна обработка всего объема данных за 21 секунду (Macbook Air M1@16G). Подключение библиотек `set` и `oj` счел нецелесообразным так-как их добавление в проект не дало существенного эффекта*

## Защита от регрессии производительности
Для защиты от потери достигнутого прогресса при дальнейших изменениях программы *были добавлены тесты на основную метрику - 0.030 сек, на количество итераций в секунду - 45 ips на файле данных на 8000 строк. Дополнительно добавлен тест проверки линейной ассимптотики на файлах размером 1к, 2к, 4к, 8к строк*

