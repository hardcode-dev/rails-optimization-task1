Время выполнения на 5000: 0.210786
Время выполнения на 10000: 0.726360
Время выполнения на 20000: 2.843040
Время выполнения на 40000: 12.927038

рост квадратичный -> O(n^2)
f(x) ~ 8*10^-9 * x^2
время выполнения на 3250940: ~23,5 часа

1) Начнем с объема 20000 (около 3сек), напишем тест на перфманс (не больше 3 секунд)
2) используем профилировщик rbspy
3) по call tree видим, что больше всего времени уходит на блок users.each в методе work (83,8%), а в нем на блок select (58,8%) (user_sessions = sessions.select { |session| session['user_id'] == user['id'] })
4) заменим метод select на предварительную группировку по пользователям. теперь блок users.each занимает 2% времени
5) проверим время на 20000: 0.350901
5) заменим each + [] << на map. профилировщик с дефолтным значением samples per sec (97) не показал блок в статистике, поменяла на 1000 samples per sec - не показал блок в статистике
5) проверим время на 20000: 0.350526 (не изменилось)
6) поправим тест на перфманс (поставим границу 0.4 с)

1) проверим время на 40000: 1.077637, мало
2) проверим 80000: 4.540294
3) напишем перфоманс тест на 80000 (не больше 4.6 сек)
4) воспользуемся профилировщиком ruby prof flat отчет
5) по отчету видно что больше всего времени занимает конкатенация массивов:
   %self      total      self      wait     child     calls  name                           location
   30.44      2.073     2.073     0.000     0.000    80200   Array#+
6) в коде конкатенация используемся при сборке users = [], sessions = [], uniqueBrowsers = []
7) uniqueBrowsers заменила на map + uniq, users / sessions на append:
   0.62      0.007     0.007     0.000     0.000    80000   Array#append
8) время на 80000: 0.571369
9) поправим тест на перфманс (поставим границу 0.6 с)