# Case-study оптимизации

## Актуальная проблема
В нашем проекте возникла серьёзная проблема.

Необходимо было обработать файл с данными, чуть больше ста мегабайт.

У нас уже была программа на `ruby`, которая умела делать нужную обработку.

Она успешно работала на файлах размером пару мегабайт, но для большого файла она работала слишком долго, и не было понятно, закончит ли она вообще работу за какое-то разумное время.

Я решил исправить эту проблему, оптимизировав эту программу.

## Формирование метрики
Для того, чтобы понимать, дают ли мои изменения положительный эффект на быстродействие программы я придумал использовать такую метрику:
 *тут ваша метрика*
 * ruby-prof flat
 * ruby-prof. CallStack

## Гарантия корректности работы оптимизированной программы
Программа поставлялась с тестом. Выполнение этого теста в фидбек-лупе позволяет не допустить изменения логики программы при оптимизации.

## Feedback-Loop
Для того, чтобы иметь возможность быстро проверять гипотезы я выстроил эффективный `feedback-loop`,
который позволил мне получать обратную связь по эффективности сделанных изменений за 
*время, которое у вас получилось*
* Примерно за 2.5 секунды.

Вот как я построил `feedback_loop`: 
*как вы построили feedback_loop*
1. Для проверки правильности отчета использовал минимальный набор данных.
2. Для проверки скорости работы программы постепенно увеличивал размер исследуемых данных. 30к, 100к, 300к строк.


## Вникаем в детали системы, чтобы найти главные точки роста
Для того, чтобы найти "точки роста" для оптимизации я воспользовался *инструментами, которыми вы воспользовались*
    > rbspy - показывает только запущенный процесс.
    > ruby-prof flat : Показал что точка роста метод select там 86% времени находится.
    > ruby-prof. Graph Показал что точка роста метод select который вызывается each
    > ruby-prof. CallStack  Object#work -> Array#each -> Array#select 83% времени 
    > ruby-prof. CallTreePrinter  Object#work -> Array#each -> Array#select 83% времени   - так же показывает.
    > stackprof указывает на тот же метод.
    >
    >

Вот какие проблемы удалось найти и решить

### Ваша находка №1
- какой отчёт показал главную точку роста
    ruby-prof flat. метод select там 86% 
    82.95      2.480     2.480     0.000     0.000     1279   Array#select
    файл data10000.txt выполнялся за Total: 2.989943
- как вы решили её оптимизировать
поменял способ сбора сессий, не массив хешей, а ассоциативный массив.
- как изменилась метрика
        файл data10000.txt выполнялся за Total: 0.466597    в 6 раз стало быстрее.

- как изменился отчёт профилировщика - исправленная проблема перестала быть главной точкой роста?
    да сейчас стал метод each
     58.21      0.441     0.272     0.000     0.169     8353  *Array#each 

### Ваша находка №2
Увеличим файл до 30 000 строк. чтобы метрики были поточней и побольше.  Total: 2.741800
- какой отчёт показал главную точку роста 
    ruby-prof flat
 73.59      2.642     2.018     0.000     0.625    30010  *Array#each  
 ----------------------------
 ruby-prof. CallStack
 100.00% (100.00%) Object#work [1 calls, 1 total]
     75.33% (75.33%) Array#each [3 calls, 30010 total]
         15.45% (20.51%) Enumerable#all? [25408 calls, 30000 total]
            15.06% (97.46%) Array#each [25408 calls, 30010 total]
            
    15.45% (20.51%) Enumerable#all? [25408 calls - показал эту точку роста.        
 ------------------
- как вы решили её оптимизировать
уброл вызов этого количества each. В начальный массив поместил сбор всех браузеров.
и выбор уникальных браузеров стандартной функцией uniq

- как изменилась метрика
    Общая метрика чуть-чуть улучшилась Total: 2.260697
- как изменился отчёт профилировщика - исправленная проблема перестала быть главной точкой роста?
    Нет не перестала.
     67.37      2.148     1.523     0.000     0.625     4601  *Array#each 

### Ваша находка №3
23.23% (23.23%) Object#collect_stats_from_users [7 calls, 7 total]
    23.23% (100.00%) Array#each [7 calls, 4601 total]
        14.52% (62.51%) Array#map [50512 calls, 50514 total]
            7.86% (54.10%) <Class::Date>#parse [25408 calls, 25408 total]

- какой отчёт показал главную точку роста
    7.86% (54.10%) <Class::Date>#parse [25408 calls, 25408 total]
    
    выбрал эту точку роста потому что углубляясь вниз по отчету, тут больше всего процентов.
 Total: 2.260697   
- как вы решили её оптимизировать
    На текущих данных эту инструкцию можно опустить., а сортировка даты обычном способо можно сделать.
- как изменилась метрика
 Total: 2.460697   в текущей итерации стал хуже.

    15.22% (15.22%) Object#collect_stats_from_users [7 calls, 7 total]
        15.22% (100.00%) Array#each [7 calls, 4601 total]
            5.89% (38.73%) Array#map [41328 calls, 41330 total]
                1.45% (9.52%) Hash#merge [32144 calls, 32144 total]
   Но решаемая задача ушла полностью.             
- как изменился отчёт профилировщика - исправленная проблема перестала быть главной точкой роста?
    Отчет callstack позеленел
### Ваша находка №4
- какой отчёт показал главную точку роста

 77.31      2.321     1.886     0.000     0.435     4601  *Array#each  
 5.92      0.171     0.144     0.000     0.026    41330   Array#map  
 
 Попробуем еще раз поработать с Array#each  
 
- как вы решили её оптимизировать
    Чтобы не проходится еще раз по всем пользователям, попробую сразу в Объекте Юзер собирать для него всю статистику 
    и в том each может быть сразу собирать репорт. А лучше в первом прогоне собрать нужные массивы, тем самым мы уберем 
    ненужные map
- как изменилась метрика
    total  поменялся в 5 раз примерно на 30к записей..
    Убрали сейчас не нужный parce_session
    и стало гараздо лучше!
- как изменился отчёт профилировщика - исправленная проблема перестала быть главной точкой роста?
    Отчет профилировщика поменлся.

### Ваша находка №X
- какой отчёт показал главную точку роста

callstack
100.00% (100.00%) [global]# [1 calls, 1 total]
    100.00% (100.00%) Object#work [1 calls, 1 total]
        58.95% (58.95%) Array#each [2 calls, 15440 total]
        31.16% (31.16%) Object#collect_stats_from_users [7 calls, 7 total]

- как вы решили её оптимизировать
    убрать этот метод collect_stats_from_users
    
- как изменилась метрика
чуть улучшилось.
- как изменился отчёт профилировщика - исправленная проблема перестала быть главной точкой роста?
    тотал не уменьшился. Но проценты от collect_stats_from_users ушли.
### Ваша находка №X
- какой отчёт показал главную точку роста
100.00% (100.00%) Object#work [1 calls, 1 total]
    90.35% (90.35%) Array#each [2 calls, 15433 total]
        5.61% (6.21%) String#split [100000 calls, 115432 total]
        2.35% (2.60%) Array#push [338276 calls, 338276 total]
        1.86% (2.05%) Array#sort [30862 calls, 30863 total]
        1.82% (2.02%) String#upcase [169138 calls, 169138 total]
- как вы решили её оптимизировать
попробую push замениить на <<    - Сработало. действительно быстрей чем push.
1.63% (1.84%) Object#parse_user [15431 calls, 15431 total] 
Убрал parse_user
1.17% (1.32%) Class#new [15431 calls, 15431 total]
Убрал создание объекта user
- как изменилась метрика
Total: 1.086485 уменьшился вдвое.
- как изменился отчёт профилировщика - исправленная проблема перестала быть главной точкой роста?
    Проблема решилась и система заработала достаточно быстро.

### Ваша находка №X
- какой отчёт показал главную точку роста
    3.47% (4.85%) String#upcase [5501880 calls, 5501880 total]
- как вы решили её оптимизировать
    смогу уменьшить количество вызовов upcase
- как изменилась метрика
    1.89% (2.32%) String#upcase [2750940 calls, 2750940 total]
- как изменился отчёт профилировщика - исправленная проблема перестала быть главной точкой роста?
    чуть-чуть улучшилось.
### Ваша находка №X
- какой отчёт показал главную точку роста
- как вы решили её оптимизировать
- как изменилась метрика
- как изменился отчёт профилировщика - исправленная проблема перестала быть главной точкой роста?

## Результаты
В результате проделанной оптимизации наконец удалось обработать файл с данными.
Удалось улучшить метрику системы с НЕИЗВЕСТНОГО ВРЕМЕНИ, до мение 60 секунд, тем самым уложиться в заданный бюджет.


## Защита от регрессии производительности
Для защиты от потери достигнутого прогресса при дальнейших изменениях программы *о performance-тестах, которые вы написали*

