# Case-study оптимизации

## Checklist
- [x] Прикинуть зависимость времени работы программы от размера обрабатываемого файла
- [x] Построить и проанализировать отчёт `ruby-prof` в режиме `Flat`;
- [x] Построить и проанализировать отчёт `ruby-prof` в режиме `Graph`;
- [x] Построить и проанализировать отчёт `ruby-prof` в режиме `CallStack`;
- [x] Построить и проанализировать отчёт `ruby-prof` в режиме `CallTree` c визуализацией в `QCachegrind`;
- [x] Построить дамп `stackprof` и проанализировать его с помощью `CLI`
- [x] Построить дамп `stackprof` в `json` и проанализировать его с помощью `speedscope.app`
- [x] Профилировать работающий процесс `rbspy`;
- [x] Добавить в программу `ProgressBar`;
- [ ] Постараться довести асимптотику до линейной и проверить это тестом;
- [x] Написать простой тест на время работы: когда вы придёте к оптимизированному решению, замерьте, сколько оно будет работать на тестовом объёме данных; и напишите тест на то, что это время не превышается (чтобы не было ложных срабатываний, задайте время с небольшим запасом);


## Актуальная проблема
Запуск программы с данными в 12 500 срок показало работу в 2.3 секунд.
Запуск программы с данными в 25 000 срок показало работу в 8 секунд.
Запуск программы с данными в 50 000 срок показало работу в 55 секунд.
Запуск программы с данными в 100 000 срок показало работу в 257 секунд.

Тут видно, что с увеличением строк в файле в два раза, процесс обработки увеличивается более чем в 5 раз.

То есть если файл будет с 3 250 940 строк, то этот файл может обрабатываться примерно неделю.

Моя первая цель ускорить обработку файла в 25 000 срок до 2 секунд. Это примерная оценка из "потолка".

## Формирование метрики
Для понимания процесса обработки данных я использовал метрику *Benchmark*. Так я могу видеть время работы программы

## Гарантия корректности работы оптимизированной программы
Программа поставлялась с тестом.

Выполнение этого теста в фидбек-лупе позволяет не допустить изменения логики программы при оптимизации.

Еще добавлен тест на время выполнения теста.

## Feedback-Loop
Для того, чтобы иметь возможность быстро проверять гипотезы я выстроил эффективный `feedback-loop`, который позволил мне получать обратную связь по эффективности сделанных изменений за *время, которое у вас получилось*

Вот как я построил `feedback_loop`: *как вы построили feedback_loop*

- Для начала я запустил Rbspy что бы обнаружить точку роста. 99% времени работа происходит в этом блоке кода block in work - task-1.rb:63

- Ruby-prof в режиме Flat показал точку роста в вызове метода Array#select

- Ruby-prof в режиме Graph так же показал точку роста в Array#select и вызывался из Array#each

- В Ruby-prof в режиме callgrind получил красивый отчет, так же показан рост в Array#select

- StackProf показал основное время работы в Object#work

- StackProf в формате json на много интереснее получается и так же информативно


## Вникаем в детали системы, чтобы найти главные точки роста
Для того, чтобы найти "точки роста" для оптимизации я воспользовался *инструментами, которыми вы воспользовались*

Вот какие проблемы удалось найти и решить

### Ваша находка №1
- Ruby-prof в режиме Graph так же показал точку роста в Array#select
- Самое главное что я сделал, это первую обработку данных. Что бы все было структурировано и была некая связь между пользователем и его сессиями. После этого внес правки в весь код, что бы тесты начали выполняться
- Метрика стала на много лучше . Запуск программы с данными в 25 000 срок показало работу в 0.8 секунд. Это укладывается в мой первоначальный бюджет.
- Теперь профилировщик показывает две точки роста. Это 71% Object#collect_stats_from_users и 50% Array#map

### Ваша находка №2
- Ruby-prof в режиме Graph так же показал две точки роста 71% в Object#collect_stats_from_users и 50% в Array#map
- как вы решили её оптимизировать
- как изменилась метрика
- как изменился отчёт профилировщика - исправленная проблема перестала быть главной точкой роста?

### Ваша находка №X
- какой отчёт показал главную точку роста
- как вы решили её оптимизировать
- как изменилась метрика
- как изменился отчёт профилировщика - исправленная проблема перестала быть главной точкой роста?

## Результаты
В результате проделанной оптимизации наконец удалось обработать файл с данными.  
Удалось улучшить метрику системы с *того, что у вас было в начале, до того, что получилось в конце* и уложиться в заданный бюджет.

*Какими ещё результами можете поделиться*

## Защита от регрессии производительности
Для защиты от потери достигнутого прогресса при дальнейших изменениях программы *о performance-тестах, которые вы написали*