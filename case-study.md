# Case-study оптимизации

## Актуальная проблема
В нашем проекте возникла серьёзная проблема.

Необходимо было обработать файл с данными, чуть больше ста мегабайт.

У нас уже была программа на `ruby`, которая умела делать нужную обработку.

Она успешно работала на файлах размером пару мегабайт, но для большого файла она работала слишком долго, и не было понятно, закончит ли она вообще работу за какое-то разумное время.

Я решил исправить эту проблему, оптимизировав эту программу.

## Формирование метрики
Для того, чтобы понимать, дают ли мои изменения положительный эффект на быстродействие программы я придумал использовать такую метрику: время выполнения скрипта

## Гарантия корректности работы оптимизированной программы
Программа поставлялась с тестом. Выполнение этого теста в фидбек-лупе позволяет не допустить изменения логики программы при оптимизации.

## Feedback-Loop
Для того, чтобы иметь возможность быстро проверять гипотезы я выстроил эффективный `feedback-loop`, который позволил мне получать обратную связь по эффективности сделанных изменений за одну минуту, путем уменьшения количества обрабатываемых срок.

Вот как я построил `feedback_loop`: 
- проверка времени выполнения скрипта rspec-benchmark
- профилирование скрипта ruby-prof
- выявление точки роста
- оптимизация точки роста

## Вникаем в детали системы, чтобы найти главные точки роста
Для того, чтобы найти "точки роста" для оптимизации я воспользовался rspec-benchmark, ruby-prof

Вот какие проблемы удалось найти и решить

### Ваша находка №1
- ruby-prof flat показал 89.54% выполнения Array#select
- сгрупировать сессии по пользователям
- метрика стала занимать значительно меньше
- исправленная проблема перестала быть главной точкой роста, метрика опустилась вниз списка

### Ваша находка №2
- ruby-prof callstack показал 40.27% выполнения Array#all?
- заменить проверку на уникальность uniq в готовом массиве
- после замера времени исполнения скрипта rspec-benchmark на файле в 10000 строк время выполнения составило 338 ms, было решено попробовать заменить uniq на Set.new, после этого время выполнения сократилось до 202 ms.
- метрика стала занимать значительно меньше времени
- исправленная проблема перестала быть главной точкой роста, метрика опустилась вниз списка

### Ваша находка №3
- ruby-prof callstack показал 25.17% (65.46%) Array#map
- сгрупировать в один метод, заменить двойной map в датах сессий через запятую в обратном порядке в формате iso8601, так как в файле они уже хранятся в iso8601
- метрика стала занимать около 4.80%
- исправленная проблема перестала быть главной точкой роста

### Ваша находка №4
- ruby-prof callstack показал 3.02% (48.93%) String#split
- удалить лишний split
- Array#each в который входит split занимал 78.21% (78.22%), после изменений сократился до 48.16% (48.17%), время работы скрипта значительно сократилось. При анализе 100000 срок, время работы составляло около 60 секунд, после улучшения время работы составило около 2 секунд.
- исправленная проблема перестала быть главной точкой роста

## Результаты
В результате проделанной оптимизации наконец удалось обработать файл с данными.
Удалось улучшить метрику системы в несколько раз, но уложиться в заданный бюджет в 30 секунд не удалось. Лучший результат был достигнут при обработке 500000 строк, и время обработки составило 86 секунд. Увеличение количества строк приводило к убиванию процесса.

## Защита от регрессии производительности
Для защиты от потери достигнутого прогресса при дальнейших изменениях программы был написан тест для замера времени исполнения на rspec-benchmark

