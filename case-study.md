# Case-study оптимизации

## Актуальная проблема
В нашем проекте возникла серьёзная проблема.

Необходимо было обработать файл с данными, чуть больше ста мегабайт.

У нас уже была программа на `ruby`, которая умела делать нужную обработку.

Она успешно работала на файлах размером пару мегабайт, но для большого файла она работала слишком долго, и не было понятно, закончит ли она вообще работу за какое-то разумное время.

Я решил исправить эту проблему, оптимизировав эту программу.

## Формирование метрики
Для того, чтобы понимать, дают ли мои изменения положительный эффект на быстродействие программы я придумал использовать такую метрику: Файл размером 128M(3250940 строк) должен обрабатываться за 30 секунд.

## Гарантия корректности работы оптимизированной программы
Программа поставлялась с тестом. Выполнение этого теста в фидбек-лупе позволяет не допустить изменения логики программы при оптимизации.

## Feedback-Loop
Для того, чтобы иметь возможность быстро проверять гипотезы я выстроил эффективный `feedback-loop`, который позволил мне получать обратную связь по эффективности сделанных изменений за *время, которое у вас получилось*

Вот как я построил `feedback_loop`: 
- перенес существующий тест в более удобное место и рядом создал тест с performance промежуточными и итоговым
- заранее разбил файлы и сложил в отдельную папку data, на 5_000, 10_000, 20_000, 30_000 и тд. Скриптом
- отдельные написал скрипты для профилировщиков и сделал возможность указывать через ENV `FILE_SIZE=10000 ruby profilers/rubyprof_graph.rb`
- первые 2 итерации пробовал разные отчеты, но по итогу пришел к использованию rubyprof_graph иногда с чередованием stackprof_cli

## Вникаем в детали системы, чтобы найти главные точки роста
Для того, чтобы найти "точки роста" для оптимизации я воспользовался

Предварительные замеры  benchmark виден рост скорости, в среднем в 2 раза величивая время.
GB_OFF=1 FILE_SIZE=10000 ruby profilers/benchmark.rb
  1.746674   0.125046   1.871720 (  1.873619)
GB_OFF=1 FILE_SIZE=20000 ruby profilers/benchmark.rb
  9.431936   0.591053  10.022989 ( 10.173283)
GB_OFF=1 FILE_SIZE=30000 ruby profilers/benchmark.rb
 15.142661   1.062562  16.205223 ( 16.214299)

дальше использовались rubyprof, stackprof

Вот какие проблемы удалось найти и решить

### Ваша находка №1
- предваритаельно по всем отчетам видно что 85 процентов времени занимает select на 101 строчке, что является селектом сессий
```
99.80%	0.85%	7.80	0.07	0.00	7.73	10	Array#each	
 6.75	4.81	0.00	1.94	1536/1536	Array#select	101
```
- Заменить поиск по массиву, предварительной подготовкой хэша сессий по пользователю
- сразу видны изменения по benchmark
```
GB_OFF=1 FILE_SIZE=10000 ruby profilers/benchmark.rb
  0.287000   0.117284   0.404284 (  0.406841)

GB_OFF=1 FILE_SIZE=20000 ruby profilers/benchmark.rb
  0.736604   0.470229   1.206833 (  1.211173)

GB_OFF=1 FILE_SIZE=30000 ruby profilers/benchmark.rb
  1.345629   0.993643   2.339272 (  2.342273)
```
- проблема ушла, теперь на профилировщике видны новые точки роста

### Ваша находка №2
- используя rubyprof через отчеты graph 
```
53.92% 6.43	6.43	0.00	0.00	57895/57895	Array#+	54
```
отчет и rbspy
```
 56.49 65.61 block in work - rails-optimization-task1/work.rb:56
```
определяем новую точку роста
- видно что больше всего времени занимает складывание массивов
- как вы решили её оптимизировать
- как изменилась метрика
- как изменился отчёт профилировщика - исправленная проблема перестала быть главной точкой роста?

### Ваша находка №X
- какой отчёт показал главную точку роста
- как вы решили её оптимизировать
- как изменилась метрика
- как изменился отчёт профилировщика - исправленная проблема перестала быть главной точкой роста?

## Результаты
В результате проделанной оптимизации наконец удалось обработать файл с данными.
Удалось улучшить метрику системы с *того, что у вас было в начале, до того, что получилось в конце* и уложиться в заданный бюджет.

*Какими ещё результами можете поделиться*

## Защита от регрессии производительности
Для защиты от потери достигнутого прогресса при дальнейших изменениях программы *о performance-тестах, которые вы написали*

