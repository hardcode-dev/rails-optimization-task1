# Ход выполнения задачи (чеклист)

## [x] ProgressBar
Не даст реального прогресса итераций -- основная обработка будет ниже цикла по строкам

## Время работы программы в зависимости от размера обрабатываемого файла

### Первый эксперимент
| Кол-во строк | Время всего |                               Основной цикл |
|--------------|-------------|---------------------------------------------|
| 50 000       |  98.073135s | 2.661192   3.306939   5.968131 (  7.372683) |
| 20 000       |  16.392062s | 0.397323   0.424769   0.822092 (  0.937124) |
| 10 000       |   4.504078s | 0.105436   0.089809   0.195245 (  0.198037) |
|  5 000       |   1.516187s | 0.033380   0.024044   0.057424 (  0.059473) |
|  1 000       |   0.790593s | 0.003793   0.001045   0.004838 (  0.004884) |
|      0       |   0.731707s | 0.000015   0.000044   0.000059 (  0.000063) |

### Второй эксперимент
| Кол-во строк |                                      Время |
|--------------|--------------------------------------------|
| 0 |   0.922668   0.288691   1.211359 (  1.324844) |
| 100 |   1.385575   0.176036   1.561611 (  1.601957) |
| 200 |   0.873091   0.159030   1.032121 (  1.048620) |
| 500 |   1.326376   0.159917   1.486293 (  1.501805) |
| 1000 |   1.233477   0.155291   1.388768 (  1.405454) |
| 2000 |   1.278277   0.158152   1.436429 (  1.455170) |
| 5000 |   1.723858   0.178938   1.902796 (  1.932623) |
| 10000 |   4.101404   0.389020   4.490424 (  4.618255) |
| 20000 |  13.757011   1.013136  14.770147 ( 15.085536) |
| 50000 |  73.247726   4.196170  77.443896 ( 78.699456) |
| 100000 | 255.687697  12.584914 268.272611 (272.068167) |
| 200000 | 1125.481167  47.655070 1173.136237 (1193.100580) |

Видна степенная зависимость, с маленькой (1.32с) постоянной составляющей.
Можно логически предположить, что это время, затрачиваемое на чтение файла.
Однако оно относительно мало для большого числа строк, где видна
нарастающая деградация выполнения.

### Рабочий ПК
| 0 |   0.777123   0.123195   0.900318 (  0.901239) |
| 100 |   0.806509   0.060019   0.866528 (  0.867244) |
| 200 |   0.937834   0.063131   1.000965 (  1.001890) |
| 500 |   1.017902   0.063459   1.081361 (  1.082327) |
| 1000 |   1.205466   0.066566   1.272032 (  1.273277) |
| 2000 |   1.063949   0.083089   1.147038 (  1.148156) |
| 5000 |   1.389884   0.056664   1.446548 (  1.447794) |
| 10000 |   2.310630   0.063052   2.373682 (  2.384505) |
| 20000 |   6.984266   0.079756   7.064022 (  7.078016) |
| 50000 |  69.412185   0.153053  69.565238 ( 69.673369) |
| 100000 | 326.694430   0.252975 326.947405 (327.526134) |
| 200000 | 1001.371670   0.554540 1001.926210 (1003.852305) |


## [x] Построить и проанализировать отчёт ruby-prof в режиме Flat;
```
Total: 2.101405
Sort by: self_time

%self      total      self      wait     child     calls  name                           location
48.62      1.022     1.022     0.000     0.000      774   Array#select
34.13      0.717     0.717     0.000     0.000    10001   String#split
4.18      1.280     0.088     0.000     1.192       41  *Array#each

Total: 7.727716
Sort by: self_time

 %self      total      self      wait     child     calls  name                           location
 65.84      5.088     5.088     0.000     0.000     1536   Array#select                   
 18.03      1.393     1.393     0.000     0.000    20001   String#split                   
  9.55      6.240     0.738     0.000     5.502       41  *Array#each   
```
Видно, что идет множественный вызов `#select`, по коду при этом можно понять,
что входной файл обрабатывается каждый раз для нового пользователя.
Это можно считать слабым местом.

## [x] Построить и проанализировать отчёт ruby-prof в режиме Graph;
```
 	 	        4.30	0.03	0.00	4.27	2/41	    Object#work	    79
80.87%	7.32%	5.37	0.49	0.00	4.88	41      	*Array#each	
 	 	        4.11	4.11	0.00	0.00	1536/1536	Array#select	101
---
	 	        4.11	4.11	0.00	0.00	1536/1536	Array#each	
61.98%	61.98%	4.11	4.11	0.00	0.00	1536	    Array#select

```

Результат примерно тот же, что и предыдущем случае, но видно, что:

- основное время уходит на `Array#each`, что говорит о том, что затратна сама
  итерация по массиву, а не выполнение проверки условия.
- Четко видно, что наиболее затратная строчка -- та, про которую можно было
  сделать предположение при предыдущем профайлинге:
```ruby
    user_sessions = sessions.select { |session| session['user_id'] == user['id'] }
```

## [x] Построить и проанализировать отчёт ruby-prof в режиме CallStack;
Видим примерно то же самое, что и для Flat:
```
Thread: 260, Fiber: 240 (100.00% ~ 5.872050523001235)
  100.00% (100.00%) Object#profile_using_ruby_prof [1 calls, 1 total]
    100.00% (100.00%) Object#do_work [1 calls, 1 total]
      100.00% (100.00%) Object#work [1 calls, 1 total]
        61.62% (61.62%) Array#each [2 calls, 41 total]
          58.93% (95.64%) Array#select [1536 calls, 1536 total]
```

## [x] Построить и проанализировать отчёт ruby-prof в режиме CallTree c визуализацией в QCachegrind;
Примерно то же, что и для Graph

## [x] Построить дамп stackprof и проанализировать его с помощью CLI
```
==================================
  Mode: wall(1000)
  Samples: 3421 (17.47% miss rate)
  GC: 0 (0.00%)
==================================
     TOTAL    (pct)     SAMPLES    (pct)     FRAME
      3421 (100.0%)        3178  (92.9%)     Object#work
       191   (5.6%)         191   (5.6%)     ProgressBar#increment!
       100   (2.9%)          18   (0.5%)     Object#collect_stats_from_users
```
Уточняем метод, точно видим снова проблемное место:
```
$ stackprof report/stackprof.dump --method "Object#work"
Object#work (/Users/dave/dev/rails-optimization-task1/src/work.rb:43)
  samples:  3178 self (92.9%)  /   3421 total (100.0%)
  callers:
    6434  (  188.1%)  Object#work
    3421  (  100.0%)  Object#do_work
      82  (    2.4%)  Object#collect_stats_from_users
  callees (243 total):
    6434  ( 2647.7%)  Object#work
     191  (   78.6%)  ProgressBar#increment!
     100  (   41.2%)  Object#collect_stats_from_users
      15  (    6.2%)  Object#parse_session
      13  (    5.3%)  User#initialize
       5  (    2.1%)  Object#parse_user
       1  (    0.4%)  ProgressBar#initialize
  code:
....
 3014   (88.1%)                   |   100  |   users.each do |user|
                                  |   101  |     attributes = user
 5972  (174.6%) /  2986  (87.3%)  |   102  |     user_sessions = sessions.select { |session| session['user_id'] == user['id'] }
   14    (0.4%) /     1   (0.0%)  |   103  |     user_object = User.new(attributes: attributes, sessions: user_sessions)
                                  |   104  |     users_objects = users_objects + [user_object]
   14    (0.4%) /    14   (0.4%)  |   105  |   end
....
```
## [x] Построить дамп stackprof в json и проанализировать его с помощью speedscope.app
Не удалось увидеть ничего глубже метода `#work`.  Возможно, в слкдующих итерациях будет работоспособнее.
## [ ] Профилировать работающий процесс rbspy; 
Тут все понятно, много использовал.



# Фидебэк-луп

> TODO: Case study 


## Итерация 1

### какой отчёт показал главную точку роста
rbSpy, flamegraph, строка:
```ruby
  user_sessions = sessions.select { |session| session['user_id'] == user['id'] }
```
### как вы решили её оптимизировать
Избавиться от множественного обхода `sessions`, используя для хранения данных хэши.
### как изменилась метрика
`  3.603002   0.355348   3.958350 (  4.002879)` => `0.794040   0.313413   1.107453 (  1.129222)`
### как изменился отчёт профилировщика - исправленная проблема перестала быть главной точкой роста?
Изменился, перестала. Однако, теперь проблемное место в rbSpy представляет собой `c function`.
Ruby-prof при этом показывает деградацию в:
```ruby
  file_lines = File.read(file_name).split("\n")
```


## Итерация 2

### какой отчёт показал главную точку роста
Ruby-prof, callstack
### как вы решили её оптимизировать
ProgressBar сделан отключаемым и отключен.
### как изменилась метрика
`0.173533   0.083631   0.299797 (  0.300288)` => `0.159331   0.093086   0.252417 (  0.252759)`
### как изменился отчёт профилировщика - исправленная проблема перестала быть главной точкой роста?
Перестала, код исключен. Теперь видно влияние как чтения файла (которое уже алгоритмически просто так не оптимизировать), так и `#collect_stats_from_user`:
```
99.99% (100.00%) Object#work [1 calls, 1 total]
  35.34% (35.34%) Enumerator#with_index [1 calls, 1 total]
    35.34% (100.00%) IO#each [1 calls, 2 total]
  31.58% (31.58%) Object#collect_stats_from_users [7 calls, 7 total]
```

# Итерация 3

### какой отчёт показал главную точку роста
Ruby-prof, callstack
### как вы решили её оптимизировать
ProgressBar сделан отключаемым и отключен.
### как изменилась метрика
`0.173533   0.083631   0.299797 (  0.300288)` => `0.159331   0.093086   0.252417 (  0.252759)`
### как изменился отчёт профилировщика - исправленная проблема перестала быть главной точкой роста?
Перестала, код исключен. Теперь видно влияние как чтения файла (которое уже алгоритмически просто так не оптимизировать), так и `#collect_stats_from_user`:
```
99.99% (100.00%) Object#work [1 calls, 1 total]
  35.34% (35.34%) Enumerator#with_index [1 calls, 1 total]
    35.34% (100.00%) IO#each [1 calls, 2 total]
  31.58% (31.58%) Object#collect_stats_from_users [7 calls, 7 total]
```


## Итерация 4

### какой отчёт показал главную точку роста
Ruby-prof, callstack
### как вы решили её оптимизировать
`#collect_stats_from_users` вызывается похожим образом много раз. Вызовы объединены. Для исключения дополнительных обходов массивов вычисление общего и максимального времени сессий перенесено в класс `User`. Также туда перенесено формирование ключа пользователя и оптимизировано создание строки этого ключа.
### как изменилась метрика
`0.159331   0.093086   0.252417 (  0.252759)` => `0.136956   0.000037   0.136993 (  0.137158)`
### как изменился отчёт профилировщика - исправленная проблема перестала быть главной точкой роста?
Место осталось затратным, но перестало быть основным: в топ вылез вызов `#all?`:
```
99.99% (100.00%) Object#work [1 calls, 1 total]
  48.38% (48.38%) Array#each [2 calls, 3 total]
    40.49% (83.69%) Array#all? [8464 calls, 10000 total]
    3.19% (6.59%) User#add_session [8464 calls, 8464 total]
  24.58% (24.58%) Object#collect_stats_from_users [1 calls, 1 total]
```

```
 %self      total      self      wait     child     calls  name
 38.01      0.115     0.114     0.000     0.000    10000   Array#all?                     
 11.14      0.055     0.034     0.000     0.022        2   IO#each 
```


## Итерация 5

### какой отчёт показал главную точку роста
Ruby-prof, flat, callstack
### как вы решили её оптимизировать
Определение уникальных браузеров вынесено в формирование сессий при чтении файла и оптимизировано определение, есть ли уже такой браузер.
### как изменилась метрика
`0.136956   0.000037   0.136993 (  0.137158)` => `0.097219   0.003425   0.100644 (  0.100777)`
### как изменился отчёт профилировщика - исправленная проблема перестала быть главной точкой роста?
Да. Теперь вылез на первое место парсинг дат:
```
99.99% (99.99%) Object#work [1 calls, 1 total]
  55.81% (55.81%) Object#collect_stats_from_users [1 calls, 1 total]
    55.81% (100.00%) Array#each [1 calls, 2 total]
      43.17% (77.36%) Array#map [10752 calls, 10754 total]
        30.28% (70.13%) <Class::Date>#parse [8464 calls, 8464 total]
```
```
 %self      total      self      wait     child     calls  name
 11.71      0.076     0.020     0.000     0.055    10754   Array#map                      
 11.24      0.049     0.020     0.000     0.029     8464   <Class::Date>#parse    
```

## Итерация 6

### какой отчёт показал главную точку роста
Ruby-prof, flat, callstack
### как вы решили её оптимизировать
Отказаться от работы с типом `Date` (для сортировки дат в формате ISO 8266 можно работать со строками). Избавиться от последовательных вызовов `#map`.
### как изменилась метрика
`0.097219   0.003425   0.100644 (  0.100777)` => `0.057720   0.000109   0.057829 (  0.057887)`
### как изменился отчёт профилировщика - исправленная проблема перестала быть главной точкой роста?
Перестала. Стали видны в основном вызовы основных языковых конструкций.
Была замерена общая производительность -- бюджет достигнут.

