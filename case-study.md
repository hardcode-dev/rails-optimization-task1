# Case-study оптимизации

## Актуальная проблема
В нашем проекте возникла серьёзная проблема.

Необходимо было обработать файл с данными, чуть больше ста мегабайт.

У нас уже была программа на `ruby`, которая умела делать нужную обработку.

Она успешно работала на файлах размером пару мегабайт, но для большого файла она работала слишком долго, и не было понятно, закончит ли она вообще работу за какое-то разумное время.

Я решил исправить эту проблему, оптимизировав эту программу.

## Формирование метрики
Для того, чтобы понимать, дают ли мои изменения положительный эффект на быстродействие программы я придумал использовать такую метрику:

Бюджет у нас в секундах, поэтому будем измерять время выполнения программы в секундах, с помощью `benchmark`. Так как программа с полным файлом слишком долго выполняется, я решил взять первую тысячу строк, потом х2, х4, х8, x16, чтобы посчитать время выполнения и ассимптотику.

Результаты измерений с исходным кодом программы:

| Количество строк | Среднее время выполнения |
|:----------------:|:------------------------:|
| 1 000            | 0.041403                 |
| 2 000            | 0.123288                 |
| 4 000            | 0.402989                 |
| 8 000            | 1.773411                 |
| 16 000           | 7.679319                 |

На основании этих данных можно понять, что ассимптотика квадратичная или даже кубическая (коэффициент корреляции кубической регрессии чуть выше квадратичной), что немножко не укладывается в наш бюджет при выполнении программы с полным файлом на 3 млн строк :).

## Гарантия корректности работы оптимизированной программы
Программа поставлялась с тестом. Выполнение этого теста в фидбек-лупе позволяет не допустить изменения логики программы при оптимизации.

## Feedback-Loop
Для того, чтобы иметь возможность быстро проверять гипотезы я выстроил эффективный `feedback-loop`, который позволил мне получать обратную связь по эффективности сделанных изменений за *время, которое у вас получилось*

Вот как я построил `feedback_loop`: *как вы построили feedback_loop*

## Вникаем в детали системы, чтобы найти главные точки роста
Для того, чтобы найти "точки роста" для оптимизации я воспользовался профилировщиками `ruby-prof` в режимах `Flat`,

Вот какие проблемы удалось найти и решить

### Находка №1 - `Array#select`
- `ruby-prof` в режиме `Flat`
- Честно говоря, первыми в голову пришли более глобальные идеи, но так как мы хотим двигаться постепенно, то решил начать с малого и сделать что-то с этим селектом. Появилась идея о том, что одна сессия может принадлежать только одному юзеру, поэтому, когда мы её привязываем к юзеру, её можно убрать из общего массива sessions. Погуглил метод, который работает как селект, но при этом удаляет выбранные элементы из старого массива, самым подходящим показался `#partition`.
- Как изменилась метрика:

|   Количество строк  |   Предыдущий результат  |   Новый результат  |   Разница  |   Разница (%)  |
|---------------------|-------------------------|--------------------|------------|----------------|
|   1 000             |   0,0414                |   0,0312           |   -0,0102  |   24,5         |
|   2 000             |   0,1233                |   0,0916           |   -0,0317  |   25,7         |
|   4 000             |   0,4030                |   0,2781           |   -0,1249  |   31,0         |
|   8 000             |   1,7734                |   0,9359           |   -0,8375  |   47,2         |
|   16 000            |   7,6793                |   3,7027           |   -3,9766  |   51,8         |

На первый взгляд это казалось хорошим результатом, но ассимптотика была не совсем понятна, поэтому я добавил файл на 32 000 строк и по результатам решил, что ассимптотика ухудшилась.

| Количество строк | Предыдущий результат | Новый результат | Разница | Разница (%) |
|:----------------:|:--------------------:|:---------------:|:-------:|:-----------:|
| 32 000           | 23,426666            | 14,165618       | -9,2610 | 39,5        |

- Отчёт профилировщика показывал, что по сути точка роста сохранилась, поменялось только её название :) Откатываем изменения.

### Находка №2 - тот же `Array#select`
- `ruby-prof` в режиме `Graph`
- Вернёмся к более глобальным идеям и одна из них состоит в том, чтобы ещё в первом цикле, который идёт по строкам файла, сразу же привязывать сессию к юзеру. Таким образом, если строка в файле является юзером - мы сразу инициируем объект `User` с пустым массивом сессий, а если это сессия, то ищем юзера в массиве с помощью `#find` по `id` и добавляем сессию к нему.
- Как изменилась метрика:

|   Количество строк  |   Предыдущий результат  |   Новый результат  |   Разница   |   Разница (%)  |
|---------------------|-------------------------|--------------------|-------------|----------------|
|   1 000             |   0,0414                |   0,02801          |   -0,0134   |   32,4         |
|   2 000             |   0,1233                |   0,07961          |   -0,0437   |   35,4         |
|   4 000             |   0,4030                |   0,21860          |   -0,1844   |   45,8         |
|   8 000             |   1,7734                |   0,70163          |   -1,0718   |   60,4         |
|   16 000            |   7,6793                |   2,64729          |   -5,0320   |   65,5         |
|   32 000            |   23,426666             |   9,94190          |   -13,4848  |   57,6         |
Результат лучше, но всё ещё непонятна ассимптотика, судя по последней строке, вероятно ухудшение производительности с ростом объема файла, возможно результат будет даже хуже, но теперь хотя бы есть идея на следующую итерацию!

- Точка роста теперь `Enumerable#find`

### Ваша находка №X
- какой отчёт показал главную точку роста
- как вы решили её оптимизировать
- как изменилась метрика
- как изменился отчёт профилировщика - исправленная проблема перестала быть главной точкой роста?

## Результаты
В результате проделанной оптимизации наконец удалось обработать файл с данными.
Удалось улучшить метрику системы с *того, что у вас было в начале, до того, что получилось в конце* и уложиться в заданный бюджет.

*Какими ещё результами можете поделиться*

## Защита от регрессии производительности
Для защиты от потери достигнутого прогресса при дальнейших изменениях программы *о performance-тестах, которые вы написали*

