##Feedback-loop
Первым делом создал файлы с количеством строк 10к, 30к, 60к и так далее.
Написал скрипты для всех профилировщиков.

## Step 1
Сделал отчет используя ruby-prof в режиме Flat на файле с 10к строками.
В метрику вложились. Ничего не поменял.

## Step 2
Сделал отчет используя ruby-prof в режиме Flat на файле с 30к строками.
- Главная точка точка `Array#select`. Проблема получается в том что мы делаем поиск сессий пользователя в огромном массиве.
- Решил отказаться от поиска по массиву в сторону формирования хеша у которого ключи это id пользователей а значение это массив сессий пользователя.
- На 30к строках метрика уменьшилась с 60 секунд до 3 секунд
- Отчет профилировщика показал что данная проблема решена.

## Step 3
Сделал отчет используя ruby-prof в режиме Flat на файле с 60к строками.
В метрику вложились. Ничего не поменял.

## Step 4
Сделал отчет используя ruby-prof в режиме Flat на файле с 120к строками.
Сделал отчет используя ruby-prof в режиме Graph на файле с 120к строками.
- Главная точка роста `Array#each`. Так как в коде не так много мест где вызывается `Array#each` я предположил
  что основная часть времени уходит на формирование массива с уникальными браузерами, так как приходится еще раз пробегать
  по огромному массиву с сессиями + заменил метод `all?` на проверку `include?`.
- Решил перенести формирование массива с уникальными браузерами в тот же итератор где парсятся строки и формируются данные.
- На 120к строках метрика уменьшилась с 86 секунд до 75 секунд
- Отчет профилировщика показал что проблема ни куда не ушла.

## Step 5
Сделал отчет используя ruby-prof в режиме Flat на файле с 120к строками.
Сделал отчет используя ruby-prof в режиме Graph на файле с 120к строками.
Сделал отчет используя ruby-prof в режиме CallStack на файле с 120к строками.
Сделал отчет используя ruby-prof в режиме CallTree на файле с 120к строками.
- Главная точка роста `Array#each` сохранилась.
- Уменьшил количество вызовов `Array#each` до двух раз. Отказался от формирования объекта `User`. Формирования массива
  с уникальными браузерами вынес отдельно.
- На 120к строках метрика уменьшилась с 75 секунд до 3 секунд
- Отчет профилировщика показал что данная проблема решена.

## Step 6
Сделал отчет используя ruby-prof в режиме Flat на файле с 240к строками.
- В метрику вложились. Идем дальше.

## Step 7
Сделал отчет используя ruby-prof в режиме Flat на файле с 480к строками.
Сделал отчет используя ruby-prof в режиме Graph на файле с 480к строками.
Сделал отчет используя ruby-prof в режиме CallStack на файле с 480к строками.
Сделал отчет используя ruby-prof в режиме CallTree на файле с 480к строками.
- Точка роста `Array#each`.
- Заменил метод `Array#+=` на `Array#<<`
- На 480к строках метрика уменьшилась с 50 секунд до 10 секунд
- Отчет профилировщика показал что данная проблема решена.

## Step 8
Сделал отчет используя ruby-prof в режиме Flat на файле с 960к строками.
- В метрику вложились. Идем дальше.

## Step 9
Сделал отчет используя ruby-prof в режиме Flat на файле с 1920к строками.
- Точка роста `<Class::Date>#parse`
- Просмотрел в тесты и сравнил даты дои после преобразования. Смысла нет в парсинге. Убрал. Тесты целы.
- На 1920к строках метрика уменьшилась с 41 секунд до 23 секунд
- Отчет профилировщика показал что данная проблема решена.

## Step 10
Сделал отчет используя ruby-prof в режиме Flat на файле с 3_250_940 строками.
Сделал отчет используя ruby-prof в режиме CallStack на файле с 3_250_940 строками.
