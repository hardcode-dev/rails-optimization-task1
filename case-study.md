## Формирование метрики
За метрику использовал время выполнения программы на тестовых данных (объём данных подбирался таким образом, чтобы время выполнения программы занимало не более 2-3 секунд)
Так же ориентировался на то какой процент времени выполняется проблемный метод

## Feedback-Loop
Подобрать нужный объём тестовых данных
Запустить несколько профайлеров, по началу хватало обычного stackprof_flat, но потом пользовался обычно callstack / callgrind
Найти проблемный метод
Отрефакторить, убедиться что тесты проходят, снова запустить профайлеры

## Находки
### sessions.select
- ruby-prof callstack показал главную точку роста — 80% времени занимала строчка user_sessions = sessions.select { |session| session['user_id'] == user['id'] }
- чтобы для каждого пользователя не искать каждый раз среди огромного массива принадлежащие ему сессии, решил добавить «словарь» с ключом user_id, значением: всеми его сессиями
- для тестового файла в 10_000 строк время выполнения изменилось с 2.1 до 0.3 секунды
- отчёт изменился, исправленная проблема перестала быть главной точкой роста

### unique_browsers
- снова callstack
- отрефакторил подсчёт уникальных браузеров
- для 80_000 тысяч строк 4.5 → 4.1 
- поменялось, теперь 55% времени занимает Array.each, 30% из них Array.map

### collect_stats_from_users
- callstack / callgrind, метод выполнялся 55% времени
- сократил количество мапов, убрал лишний парсинг даты, объединил вызов нескольких collect_stats в один (не уверен что это помогло)
- 4.08 → 3.5 для 80_000 тысяч строк
- вместо 45% времени стало выполняться 20%


### each, внутри него метод +
- всё тот же, callstack, пользовался и другими, но он удобнее всего
- сложение массивов заменил на '<<'
- для 80_000 строк време выполнения: 3.5 → 0.46
- как изменился отчёт профилировщика - исправленная проблема перестала быть главной точкой роста?

### report['allBrowsers']
- он, любимый
- убрал лишние мапы, переместил uniq в начало
- для 160_000 време выполнения с 1.16с на 0.9с
- проблема ушла полностью


### снова collect_stats_from_users
- ;) + stackprof
- убрал использование блока в методе (а стоило ли?), хотел избавиться от лишнего прогона по всем пользователям, обойтись без users_objects.each, перенёс логику в users.each, но время выполнения возросло на несколько процентов
- 0.23 → 0.19 для 40_000, 0.87 → 0.85 для 160, 29.6 → 28.5 полный файл
- не особо получилось решить проблему, она скорее перенеслась в each, который теперь занимает 88%
